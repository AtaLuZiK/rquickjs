use crate::{qjs, Ctx, FromJs, IntoJs, Object, StdResult, StdString, Value};

use std::{
    error::Error as StdError,
    ffi::{CString, NulError},
    fmt::{Display, Formatter, Result as FmtResult},
    io::Error as IoError,
    str::Utf8Error,
};

/// Result type used throught the library.
pub type Result<T> = StdResult<T, Error>;

/// Error type of the library.
#[derive(Debug)]
pub enum Error {
    /// Could not allocate memory
    /// This is generally only triggered when out of memory.
    Allocation,
    /// Found a string with a internal null byte while converting
    /// to C string.
    InvalidString(NulError),
    /// String from rquickjs was not UTF-8
    Utf8(Utf8Error),
    /// An io error
    IO(IoError),
    /// An exception raised by quickjs itself.
    Exception {
        message: StdString,
        file: StdString,
        line: i32,
        stack: StdString,
    },
    /// Error converting from javascript to a rust type.
    FromJs {
        from: &'static str,
        to: &'static str,
        message: Option<StdString>,
    },
    /// Error converting to javascript from a rust type.
    IntoJs {
        from: &'static str,
        to: &'static str,
        message: Option<StdString>,
    },
    #[cfg(feature = "loader")]
    /// Error when resolving js module
    Resolving {
        base: StdString,
        name: StdString,
        message: Option<StdString>,
    },
    #[cfg(feature = "loader")]
    /// Error when loading js module
    Loading {
        name: StdString,
        message: Option<StdString>,
    },
    /// An error from quickjs from which the specifics are unknown.
    /// Should eventually be removed as development progresses.
    Unknown,
}

impl Error {
    #[cfg(feature = "loader")]
    /// Create resolving error
    pub fn resolving<B, N, M>(base: B, name: N, message: Option<M>) -> Self
    where
        StdString: From<B> + From<N> + From<M>,
    {
        Error::Resolving {
            base: base.into(),
            name: name.into(),
            message: message.map(|message| message.into()),
        }
    }

    #[cfg(feature = "loader")]
    /// Create loading error
    pub fn loading<N, M>(name: N, message: Option<M>) -> Self
    where
        StdString: From<N> + From<M>,
    {
        Error::Loading {
            name: name.into(),
            message: message.map(|message| message.into()),
        }
    }

    /// Returns whether the error is a quickjs generated exception.
    pub fn is_exception(&self) -> bool {
        matches!(*self, Error::Exception{..})
    }

    /// Optimized conversion to CString
    pub(crate) fn to_cstring(&self) -> CString {
        // stringify error with NUL at end
        let mut message = format!("{}\0", self).into_bytes();

        message.pop(); // pop last NUL because CString add this later

        // TODO: Replace by `CString::from_vec_with_nul_unchecked` later when it will be stabilized
        unsafe { CString::from_vec_unchecked(message) }
    }

    /// Throw an exception
    pub(crate) fn throw(&self, ctx: Ctx) -> qjs::JSValue {
        use Error::*;
        match self {
            Allocation => unsafe { qjs::JS_ThrowOutOfMemory(ctx.ctx) },
            InvalidString(_) | Utf8(_) | FromJs { .. } | IntoJs { .. } => {
                let message = self.to_cstring();
                unsafe { qjs::JS_ThrowTypeError(ctx.ctx, message.as_ptr()) }
            }
            #[cfg(feature = "loader")]
            Resolving { .. } | Loading { .. } => {
                let message = self.to_cstring();
                unsafe { qjs::JS_ThrowReferenceError(ctx.ctx, message.as_ptr()) }
            }
            Unknown => {
                let message = self.to_cstring();
                unsafe { qjs::JS_ThrowInternalError(ctx.ctx, message.as_ptr()) }
            }
            _ => {
                let value = self.into_js(ctx).unwrap();
                unsafe { qjs::JS_Throw(ctx.ctx, value.into_js_value()) }
            }
        }
    }
}

impl StdError for Error {}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        use Error::*;

        match self {
            Allocation => "Allocation failed while creating object".fmt(f)?,
            InvalidString(error) => {
                "String contained internal null bytes: ".fmt(f)?;
                error.fmt(f)?;
            }
            Utf8(error) => {
                "Conversion from string failed: ".fmt(f)?;
                error.fmt(f)?;
            }
            Unknown => "quickjs library created a unknown error".fmt(f)?,
            Exception {
                file,
                line,
                message,
                stack,
            } => {
                "Exception generated by quickjs: ".fmt(f)?;
                if !file.is_empty() {
                    '['.fmt(f)?;
                    file.fmt(f)?;
                    ']'.fmt(f)?;
                }
                if *line >= 0 {
                    ':'.fmt(f)?;
                    line.fmt(f)?;
                }
                if !message.is_empty() {
                    ' '.fmt(f)?;
                    message.fmt(f)?;
                }
                if !stack.is_empty() {
                    '\n'.fmt(f)?;
                    stack.fmt(f)?;
                }
            }
            FromJs { from, to, message } => {
                "Error converting from js '".fmt(f)?;
                from.fmt(f)?;
                "' into type '".fmt(f)?;
                to.fmt(f)?;
                "'".fmt(f)?;
                if let Some(message) = message {
                    if !message.is_empty() {
                        ": ".fmt(f)?;
                        message.fmt(f)?;
                    }
                }
            }
            IntoJs { from, to, message } => {
                "Error converting from '".fmt(f)?;
                from.fmt(f)?;
                "' into js '".fmt(f)?;
                to.fmt(f)?;
                "'".fmt(f)?;
                if let Some(message) = message {
                    if !message.is_empty() {
                        ": ".fmt(f)?;
                        message.fmt(f)?;
                    }
                }
            }
            #[cfg(feature = "loader")]
            Resolving {
                base,
                name,
                message,
            } => {
                "Error resolving module '".fmt(f)?;
                name.fmt(f)?;
                "' from '".fmt(f)?;
                base.fmt(f)?;
                "'".fmt(f)?;
                if let Some(message) = message {
                    if !message.is_empty() {
                        ": ".fmt(f)?;
                        message.fmt(f)?;
                    }
                }
            }
            #[cfg(feature = "loader")]
            Loading { name, message } => {
                "Error loading module '".fmt(f)?;
                name.fmt(f)?;
                "'".fmt(f)?;
                if let Some(message) = message {
                    if !message.is_empty() {
                        ": ".fmt(f)?;
                        message.fmt(f)?;
                    }
                }
            }
            IO(error) => {
                "IO Error: ".fmt(f)?;
                error.fmt(f)?;
            }
        }
        Ok(())
    }
}

macro_rules! from_impls {
    ($($type:ty => $variant:ident,)*) => {
        $(
            impl From<$type> for Error {
                fn from(error: $type) -> Self {
                    Error::$variant(error)
                }
            }
        )*
    };
}

from_impls! {
    NulError => InvalidString,
    Utf8Error => Utf8,
    IoError => IO,
}

impl<'js> FromJs<'js> for Error {
    fn from_js(ctx: Ctx<'js>, value: Value<'js>) -> Result<Self> {
        let obj = Object::from_js(ctx, value)?;
        if obj.is_error() {
            Ok(Error::Exception {
                message: obj.get("message").unwrap_or_else(|_| "".into()),
                file: obj.get("fileName").unwrap_or_else(|_| "".into()),
                line: obj.get("lineNumber").unwrap_or(-1),
                stack: obj.get("stack").unwrap_or_else(|_| "".into()),
            })
        } else {
            Err(Error::FromJs {
                from: "object",
                to: "error",
                message: None,
            })
        }
    }
}

impl<'js> IntoJs<'js> for &Error {
    fn into_js(self, ctx: Ctx<'js>) -> Result<Value<'js>> {
        use Error::*;
        let value = unsafe { Value::from_js_value(ctx, qjs::JS_NewError(ctx.ctx)) }?;
        if let Value::Object(obj) = &value {
            match self {
                Exception {
                    message,
                    file,
                    line,
                    stack,
                } => {
                    if !message.is_empty() {
                        obj.set("message", message)?;
                    }
                    if !file.is_empty() {
                        obj.set("fileName", file)?;
                    }
                    if *line >= 0 {
                        obj.set("lineNumber", *line)?;
                    }
                    if !stack.is_empty() {
                        obj.set("stack", stack)?;
                    }
                }
                error => {
                    obj.set("message", error.to_string())?;
                }
            }
        }
        Ok(value)
    }
}
