diff --git a/quickjs.c b/quickjs.c
index a39ff8f..477de31 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -1252,7 +1252,12 @@ static const JSClassExoticMethods js_arguments_exotic_methods;
 static const JSClassExoticMethods js_string_exotic_methods;
 static const JSClassExoticMethods js_proxy_exotic_methods;
 static const JSClassExoticMethods js_module_ns_exotic_methods;
-static JSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;
+#ifdef CONFIG_ATOMICS
+#define JS_CLASS_ID_ALLOC_ATTRS _Atomic
+#else
+#define JS_CLASS_ID_ALLOC_ATTRS
+#endif
+static JS_CLASS_ID_ALLOC_ATTRS JSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;

 static void js_trigger_gc(JSRuntime *rt, size_t size)
 {
@@ -2108,6 +2113,13 @@ void JS_FreeRuntime(JSRuntime *rt)
     }
 }

+#ifdef CONFIG_PARALLEL
+void JS_ResetStackPointer(JSContext *ctx)
+{
+     ctx->rt->stack_top = js_get_stack_pointer();
+}
+#endif
+
 JSContext *JS_NewContextRaw(JSRuntime *rt)
 {
     JSContext *ctx;
@@ -3349,16 +3361,26 @@ static inline BOOL JS_IsEmptyString(JSValueConst v)

 /* JSClass support */

-/* a new class ID is allocated if *pclass_id != 0 */
+/* a new class ID is allocated if *pclass_id == 0 */
 JSClassID JS_NewClassID(JSClassID *pclass_id)
 {
     JSClassID class_id;
-    /* XXX: make it thread safe */
+#ifdef CONFIG_ATOMICS
+    JSClassID new_class_id;
+    new_class_id = atomic_load_explicit(&js_class_id_alloc, memory_order_acquire);
+    class_id = *pclass_id;
+    if (class_id == 0) {
+        class_id = new_class_id++;
+        *pclass_id = class_id;
+    }
+    atomic_store_explicit(&js_class_id_alloc, new_class_id, memory_order_release);
+#else
     class_id = *pclass_id;
     if (class_id == 0) {
         class_id = js_class_id_alloc++;
         *pclass_id = class_id;
     }
+#endif
     return class_id;
 }

@@ -27155,6 +27177,40 @@ void JS_SetModuleLoaderFunc(JSRuntime *rt,
     rt->module_loader_opaque = opaque;
 }

+#ifdef CONFIG_MODULE_EXPORTS
+/* Hooks into module loading functions */
+JSValueConst JS_GetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name) {
+    JSExportEntry *me;
+    JSAtom name;
+    name = JS_NewAtom(ctx, export_name);
+    if (name == JS_ATOM_NULL)
+        goto fail;
+    me = find_export_entry(ctx, m, name);
+    JS_FreeAtom(ctx, name);
+    if (!me)
+        goto fail;
+    return JS_DupValue(ctx, me->u.local.var_ref->value);
+ fail:
+    return JS_UNDEFINED;
+}
+int JS_GetModuleExportEntriesCount(JSModuleDef *m) {
+    return m->export_entries_count;
+}
+
+JSValue JS_GetModuleExportEntry(JSContext *ctx, JSModuleDef *m, int idx) {
+    if (idx >= m->export_entries_count || idx < 0)
+        return JS_UNDEFINED;
+    return JS_DupValue(ctx, m->export_entries[idx].u.local.var_ref->value);
+}
+
+JSAtom JS_GetModuleExportEntryName(JSContext *ctx, JSModuleDef *m, int idx) {
+    if (idx >= m->export_entries_count || idx < 0)
+        return JS_ATOM_NULL;
+    return JS_DupAtom(ctx, m->export_entries[idx].export_name);
+}
+#endif
+
+
 /* default module filename normalizer */
 static char *js_default_module_normalize_name(JSContext *ctx,
                                               const char *base_name,
diff --git a/quickjs.h b/quickjs.h
index 92457a2..b55d4c5 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -352,6 +352,11 @@ JSRuntime *JS_GetRuntime(JSContext *ctx);
 void JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj);
 JSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id);

+#ifdef CONFIG_PARALLEL
+void JS_ResetStackPointer(JSContext *ctx);
+#endif
+
+
 /* the following functions are used to select the intrinsic object to
    save memory */
 JSContext *JS_NewContextRaw(JSRuntime *rt);
@@ -1034,6 +1039,14 @@ int JS_SetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name,
                        JSValue val);
 int JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,
                            const JSCFunctionListEntry *tab, int len);
+
+#ifdef CONFIG_MODULE_EXPORTS
+JSValueConst JS_GetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name);
+int JS_GetModuleExportEntriesCount(JSModuleDef *m);
+JSValue JS_GetModuleExportEntry(JSContext *ctx, JSModuleDef *m, int idx);
+JSAtom JS_GetModuleExportEntryName(JSContext *ctx, JSModuleDef *m, int idx);
+#endif
+

 #undef js_unlikely
 #undef js_force_inline
