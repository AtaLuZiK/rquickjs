use std::{fmt, ops::Deref};

use crate::{qjs, Coerced, Ctx, Error, FromJs, IntoJs, Object, Result, Value};

/// A javascript error
///
/// Will turn into a error when converted to javascript but won't autmatically be thrown.
#[repr(transparent)]
pub struct Exception<'js>(Object<'js>);

impl<'js> Exception<'js> {
    /// Turns the exception into the underlying object.
    pub fn into_object(self) -> Object<'js> {
        self.0
    }

    /// Returns a reference to the underlying object.
    pub fn as_object(&self) -> &Object<'js> {
        &self.0
    }

    /// Creates an exception from an object if it is an instance of error.
    pub fn from_object(obj: Object<'js>) -> Option<Self> {
        if obj.is_error() {
            Some(Self(obj))
        } else {
            None
        }
    }

    /// Creates a new exception with a give message.
    pub fn from_message<M>(ctx: Ctx<'js>, message: M) -> Result<Self>
    where
        M: IntoJs<'js>,
    {
        let obj = unsafe {
            let value = ctx.handle_exception(qjs::JS_NewError(ctx.as_ptr()))?;
            Value::from_js_value(ctx, value)
                .into_object()
                .expect("`JS_NewError` did not return an object")
        };
        obj.set("message", message)?;
        Ok(Exception(obj))
    }

    /// Sets the exception as the current error an returns `Err(Error::Exception)`
    pub fn throw(self) -> Result<()> {
        self.0.ctx.throw(self.0.into_value())
    }
}

impl fmt::Display for Exception<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        "Exception generated by quickjs: ".fmt(f)?;
        if let Ok(file) = self.get::<_, Coerced<String>>("file") {
            '['.fmt(f)?;
            file.fmt(f)?;
            ']'.fmt(f)?;
        }
        if let Ok(line) = self.get::<_, Coerced<i32>>("file") {
            ':'.fmt(f)?;
            line.fmt(f)?;
        }
        if let Ok(message) = self.get::<_, Coerced<String>>("message") {
            ' '.fmt(f)?;
            message.fmt(f)?;
        }
        if let Ok(stack) = self.get::<_, Coerced<String>>("stack") {
            '\n'.fmt(f)?;
            stack.fmt(f)?;
        }
        Ok(())
    }
}

impl<'js> Deref for Exception<'js> {
    type Target = Object<'js>;

    fn deref(&self) -> &Self::Target {
        self.as_object()
    }
}

impl<'js> FromJs<'js> for Exception<'js> {
    fn from_js(_ctx: crate::Ctx<'js>, value: Value<'js>) -> Result<Self> {
        if let Some(obj) = value.as_object() {
            if obj.is_error() {
                return Ok(Exception(obj.clone()));
            } else {
                return Err(Error::FromJs {
                    from: value.type_name(),
                    to: "Exception",
                    message: Some("object was not an instance of error".to_string()),
                });
            }
        }
        return Err(Error::FromJs {
            from: value.type_name(),
            to: "Exception",
            message: Some("value was not a type".to_string()),
        });
    }
}

impl<'js> IntoJs<'js> for Exception<'js> {
    fn into_js(self, _ctx: crate::Ctx<'js>) -> Result<Value<'js>> {
        Ok(self.0.into_value())
    }
}
